import re
import graphviz

def read_grammar(file):
    """
    This format reads the grammar out of a text file in a specific format. It can be CFG or PCFG

    input: a text file with a grammar with the following structure:

        CFG:

        S → a | X A | A X | b
        A → R B
        B → A X | b | a
        X → a
        R → X B

        PCFG:

        S → NP VP 1.0
        NP → D N 0.4 | N N 0.25 | time 0.14 | flies 0.07 | arrow 0.14
        VP → V NP 0.6 | V ADVP 0.4
        ADVP → ADV NP 1.0
        N → time 0.4 | flies 0.2 | arrow 0.4
        D → an 1.0
        ADV → like 1.0
        V → flies 0.5 | like 0.5

        · The lowercase words are terminals.
        · The uppercase words are noterminals.
        · The left-side of the first rule is the start noterminal.
        · The "|" separates diferent rules with the same noterminal.
        · The "#" symbolizes the empty word, which is treated in the FNC_transformer class
        · Diferent symbols in a rule are separeted with spaces.
        · If it is PCFG, the probabilities will go at the end of a rule. The sum of the probabilities of the rules of a noterminal must be 1.0.

    output: a grammar tuple which contains: (noterminals -> set() ,terminals -> set() ,rules -> Dict() ,start -> string).

        The dict of rules has the following structure:
            keys: different noterminals
            values: list(list(right-side of the rule)). If we have probabilities, the last position of the inner list is the probability.
    """
    noterminals = set()
    terminals = set()
    rules = {}
    with open(file) as f:
        for line in f:
            clean_line=line.replace("â†’", "") #Erase the "→" symbol.
            l=clean_line.split() #split the line.
            if noterminals == set(): #if it is the first rule, set the start symbol.
                start = l[0]
            noterminals.add(l[0]) #add the left-symbol to the noterminals.
            s = []
            r = []
            for i in range(1,len(l)):
                if l[i].islower(): #If the word si lowercase, add it to terminals.
                    terminals.add(l[i])
                elif l[i] == "#": #Add the empty word to noterminals
                    noterminals.add(l[i])
                if l[i]=="|": #If we have the separation, we append the list and create a new one.
                    s.append(r)
                    r=[]
                elif i == len(l)-1: #If we reached the last word of the line we add it and append the list.
                    r.append(l[i])
                    s.append(r)
                else:
                    r.append(l[i]) #Add a new symbol to the inner list
            rules[l[0]]=s #Add the set of rules of this noterminal to the rules dictionary.
    return (noterminals,terminals,rules,start)

class CKY:

    """
    This class implements de CKY to check if a word is in our grammar. 
    It also adds a visualization method to see the tree of rules used to generate the word.
    input: grammar in the format returned by the read_grammar() function.
    """

    def __init__(self, Grammar):

        """Initialize the grammar variables for the class instance. Check if the grammar is not probabilistic."""

        if "." in Grammar[2][Grammar[3]][0][-1]: #Check the last element of the first list of the start symbol entry on the rules dictionary.
            raise ValueError("The grammar is probabilistic. Try with CKYProb()")

        self.noterminals = Grammar[0]
        self.terminals = Grammar[1]
        self.rules = Grammar[2]
        self.start = Grammar[3]
        
    def check_word(self, word, phrase = False):
        """
        This method checks if the word can be generated by the grammar.
        input: word, (phrase = True if the input is a phrase that must be analized word by word)
        output: True if can be generated, False if not.
        """
        if phrase == True:
            word = word.split()
        self._create_chart(word) #Create the chart
        if self.start not in self.chart[0,len(word)-1]:
            self.best_sol = None
            return False
        else:
            self.best_sol = self.start
            return True

    def _create_chart(self,word):
        """
        This private method generates the chart using the CKY algorithm.
        input: word
        output: None
        """
        self._init_chart(word) #Initializes the chart.
        for level in range(1,len(word)): #iterates to generate all the cells of the chart.
            for i in range(len(word)-level): 
                j=level+i
                cell = set()
                for k in range(level): 
                    cell=cell.union(self._combine_cells(i,i+k,i+1+k,j)) #calculates the diferent cell combination stated by the CKY algorithm.
                result = self._search_rule(cell) #search the possible rules for the possible combination of cells calculated above.
                self.chart[i,j] = result #adds the result to the chart.
    def _init_chart(self,word):
        """
        This private method inizializes a triangular chart, setting the values for the first row.
        input: word
        output: Nonev
        """
        self.chart = {}
        for i in range(len(word)):
            cell = self._search_rule({word[i]}) #Search the rule for an element of the word.
            self.chart[i,i] = cell #Adds the rule "if existing" to the position (i,i) of the chart.
    
    def _search_rule(self,symbols):
        """
        This private method searches for all the rules that generate the set of symbols passed.
        input: set of symbols
        output: dictionary of possible rules
        """
        result = {}
        count = { }
        for key,values in self.rules.items(): #Iterates through the keys and values of the rules.
            for value in values: #iterates through the different rules generated by a noterminal.
                for symbol in symbols: #iterates through the set of symbols that can be generated by the combination of cells done before.
                    c = re.sub(r"[^a-zA-Z\s]+", "", symbol) #String with only characters to separate the noterminal from the cells information.
                    s = c.split() #split the string to compare it with the value which is a list.
                    if s==value:
                        if key in result:
                            result[f"{key}{count[key]}"] = (symbol)
                            count[key] += 1
                        else:
                            result[key] = (symbol)
                            count[key] = 1 
        return result

    def _combine_cells(self,i,j,k,l):
        """
        This provate method combine the information of two cells to generate the combination of symbols that can be generated by the "parent" cell.
        input: cell indexes of the both cells (i,j) and (k,l)
        output: set of possible symbol combinations
        """
        cell1 = self.chart[i,j].keys() #Gets the no terminal of the first cell
        cell2 = self.chart[k,l].keys() #Gets the no terminal of the first cell
        new_cell = set()
        for x in cell1:
            for y in cell2:
                new_cell.add(f"{x}_{i},{j} {y}_{k},{l}") #Adds the symbols to a set. Adding the information of the cell they come from.
        return new_cell
    
    def show_tree(self,word, phrase = False):
        """
        This method opens a Graphviz window with the corresponding synthactic tree of a given ACCEPTED word by the
        initialised grammar. It creates a directed graph "h" to which the corresponding nodes and edges are added.
        This tree is the one that the grammar adopts for the given word in order to accept it.

        Pre: Graphviz must be installed and "word" should return True in the _check_word() method.
        Input: A string containing the accepted word to be visualized
        Output: It does not return anything, it just opens a Graphviz window with the created Tree.
        """
        h = graphviz.Digraph('test1',directory='PAA')    #Create graph.

        def build_graph(tree):
            """
            This is a recursive function that adds the nodes and edges to the "h" graph created on the method above.
            Input: A dictionary that represents the tree to be generated, of the form: tree = {root:(fesq.tree,fdre.tree)}.
                   If the sons are terminal, then it's of the form: tree = {root:str(terminal)}
            Output: It only returns the string representing the root node. Although, in the meantime it recursively adds the edges
                    (root,fesq),(root,fdre) to the h graph thus creating it.
            """
            root = list(tree.keys())[0]    #get root of Tree
            spl = root.split("_")          #We split the Terminal name from its position in the table, both given by a single string.
            name = spl[0]                  
            i,j = spl[1].split(",")  #get position in table to label nodes in the graph
            h.node(root,label=f'<{name}<SUB>{i}{j}</SUB>>')   #add node Root to h. We label it with HTML code to be able to use subscripts.

            if not isinstance(tree[root],tuple):    #If the root leads to a leaf (terminal node).
                root_st = f'{tree[root]}{i}{j}'     #We create an inner name for the node to avoid cycles with other same-named nodes.
                h.node(root_st,label=tree[root])    #The label remains the outer name.
                h.edge(root,root_st)
            else:
                fesq = build_graph(tree[root][0])   #We recursively call the function with both of the sons, to get their roots...
                fdre = build_graph(tree[root][1])
                h.edge(root,fesq);h.edge(root,fdre) #and create the edge

            return root
        if self.best_sol == None:
            print("This word has no parsing tree as it is not in the grammar")
            return
        if phrase == True:
            word = word.split()
        tree = self._build_tree(0,len(word)-1,self.best_sol)    #We call the function that creates the dictionary from which the tree is created. Sort of trace.
        build_graph(tree)
        h.render('h',format='png',view=True)                  #Visualize the h generated
    
    def _build_tree(self,x,y,term):
        """
        This private method generates the tree of rules used to generate the word. (The trace)
        input: cell position (x,y) and the noterminal in that cell (term)
        output: the tree generated (base case: the terminal word)
        """
        tree = {} #create the tree
        sons = self.chart[x,y][term].split()
        if len(sons)==1:
            return {f"{term}_{x},{y}":sons[0]} #Base case, terminal symbol
        #Decodify the information
        son1 = sons[0].split("_")
        son2 = sons[1].split("_")
        i,j=son1[1].split(',')
        k,l=son2[1].split(',')
        #Generate the sons
        tree[f"{term}_{x},{y}"] = (self._build_tree(int(i),int(j),son1[0]),self._build_tree(int(k),int(l),son2[0])) #Generate the sons recursively
        return tree

class CKYProb(CKY):

    def __init__(self, Grammar):

        """Initialize the grammar variables for the class instance. Check if the grammar is probabilistic."""

        if not "." in Grammar[2][Grammar[3]][0][-1]: 
            raise ValueError("The grammar is not probabilistic. Try with CKY()")

        self.noterminals = Grammar[0]
        self.terminals = Grammar[1]
        self.rules = Grammar[2]
        self.start = Grammar[3]
        
    def check_word(self, word, phrase = False):
        """
        This method checks if the word can be generated by the grammar.
        input: word, (phrase = True if the input is a phrase that must be analized word by word)
        output: The best solution if can be generated, False if not.
        """
        if phrase == True:
            word = word.split()
        self._create_chart(word)
        print(self.chart)
        if self.start not in self.chart[0,len(word)-1]:
            self.best_sol = None
            return False
        else:
            best_sol = max([(key,value[1]) for key,value in self.chart[0,len(word)-1].items() if self.start in key], key = lambda tuple: tuple[1] ) #Get the solution with a higher probability
            self.best_sol = best_sol[0] #Save this solution as an atribute to generate the best tree correctly
            return best_sol
    
    def _search_rule(self,symbols):
        """
        This private method searches for all the rules that generate the set of symbols passed.
        input: set of symbols
        output: dictionary of possible rules
        """
        count ={}
        result = {}
        for key,values in self.rules.items():
            for value in values:
                for symbol in symbols:
                    c = re.sub(r"[^a-zA-Z\s]+", "", symbol) #String with only characters
                    n = symbol.split()#String without characters
                    s = c.split()
                    if s==value[:-1]: #Check if the rules match (avoid the probability value[-1])
                        if len(n) != 1: #Check if we are initializing the chart
                            #Decodify the cell information
                            son1 = n[0].split("_")
                            son2 = n[1].split("_")
                            i,j=son1[1].split(',')
                            k,l=son2[1].split(',')
                            #Calculate the probabilities
                            prob1 = self.chart[int(i),int(j)][son1[0]][1] #Get probability 1
                            prob2 = self.chart[int(k),int(l)][son2[0]][1] #Get probability 2
                            prob_total = float(value[-1])*prob1*prob2 #Calculate the accumulate probability of this cell
                        else:
                            prob_total = float(value[-1]) 
                        if key in result:
                            result[f"{key}{count[key]}"] = (symbol,prob_total)
                            count[key] += 1
                        else:
                            result[key] = (symbol,prob_total)
                            count[key] = 1
        return result

    def _build_tree(self,x,y,term):
        """
        This private method generates the tree of rules used to generate the word. (The trace)
        input: cell position (x,y) and the noterminal in that cell (term)
        output: the tree generated (base case: the terminal word)
        """
        tree = {} #create the tree
        sons = self.chart[x,y][term][0].split()
        if len(sons)==1:
            return {f"{term}_{x},{y}":sons[0]} #Base case, terminal symbol
        #Decodify the information
        son1 = sons[0].split("_")
        son2 = sons[1].split("_")
        i,j=son1[1].split(',')
        k,l=son2[1].split(',')
        #Generate the sons
        tree[f"{term}_{x},{y}"] = (self._build_tree(int(i),int(j),son1[0]),self._build_tree(int(k),int(l),son2[0]))#Generate the sons recursively
        return tree